# 2025.10.26

- 计算复杂度
  - 时间复杂度: 通过循环轮数衡量计算次数**(重视复杂度的数量级)**, 和评测机的效率$10^8次/s$ 进行运算导出预计的完成时间，和官方的时间限制对比 
  - 空间复杂度：通过数组衡量编码的预计空间占用，和官方的内容限制对比
  - 基本单位：
    - 1 bit
    - 1 byte = 8 bits
    - 1 KB = 1024 bytes = $2^{10}$ bytes
    - 1 MB = 1024 KB
    - int 32 = bits = 4 bytes

## 动态规划（DP)

- 重复的字问题：相同结构的字问题大规模出现
- 最优子结构： 大的问题的最优解可以由小问题的最优解推出(推出方法自定义)

> 利用额外的数组空间，进行动态规划问题的状态标识，通过状态转移方程（递推）计算
>
> - 最大值，最小值
> - 计数问题

---

求斐波那契数列第n项：
$$
 f(n) = f(n-1) + f(n-2)\,\,\,\,\,\,\,n \ge 3 \\
	f(1) = f(2) = 1
$$

````cpp

int f(int n)
{
    if (n >= 3)
        return f(n - 1) + f(n - 2);
    return 1;
}

````

递归实现的时间复杂度为$O(2^n)$

- **存在重复的字问题**：使用数组作为缓存：访问f[i]之前查询，若不存在执行，执行后为缓存数组第i位赋值，若存在直接使用缓存数据，时间复杂度为$O(n)$, 但是依赖call stack
- 递推公式(dp的状态转移方程)：时间复杂度是纯粹的$O(n)$

动态规划的建模过程:

```
确认数组含义：f[i]表示斐波那契数列第n项
状态转移方程: f[i] = f[i-1]+f[i-2]  i>=3
遍历顺序 从3-n 从小到大
确认边界 f[1] = f[2] = 1
答案(状态数组的某一个位置或者某些位置处理后的信息): f[n]
```

### 爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。

```
确认数组含义：dp[i] 表示到达第 i 层楼梯的方法数
状态转移方程：dp[i] = dp[i - 1] + dp[i - 2] i >= 3
遍历顺序：3 - n
确认边界：dp[1] = 1 dp[2] = 2
答案：dp[n]
```

#### 最小花费的爬楼梯问题

> 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
> 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
>
> 请你计算并返回达到楼梯顶部的最低花费。

```
确认数组含义：dp[i] 表示到达第 i 级台阶的最小花费 
状态转移方程：dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) i >= 3 
遍历顺序：3 - n 
确认边界：dp[1] = dp[2] = cost[0] 
答案：dp[n]
```

### 线性DP

- 线性时间复杂度
- 线性阶段划分
- 线性空间形式, 随着输入规模的纬度变化，DP的过程在每一个维度上都具备线性变化过程, linear

---

#### LIS最长上升子序列

- 子序列
- 子区间
- 子集合

> 给定数组/序列 s，返回当前序列的最长的递增的子序列的长度（|s| ≤ 10^3）
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```
确认数组含义：dp[i] 表示以 s[i] 结尾的 LIS 长度
状态转移方程： for(int j = 1; j < i; j++) 
{ 
if(a[i] > a[j]) dp[i] = max(dp[i], dp[j] + 1); 
}
遍历顺序：1 - n 
确认边界：dp[i] = 1 
答案：max{dp[i]}
```

Python题解：

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        dp = [1] * len(nums)
        result = 1
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            result = max(result, dp[i]) #取长的子序列
        return result
```



#### LCS最长公共子序列

> 给定两个数组/序列（使用 AB 做名字），返回当前两个序列最长的公共的子序列的长度（序列长度 |A|, |B| ≤ 10^3）

```
确认数组含义:二维dp[i][j], 代表数组A的前i个字符和数组B的前j个字符的最长公共子序列长度
状态转移方程：
(1) 如果A[i-1] == B[j-1]，说明A和B的上一个字符相等，可以作为公共子序列，因此dp[i][j] = dp[i-1]+dp[j-1] + 1
(2) 相反，如果不想等，就说明最后一个字符不能同时加入LCS，只能取最大的,因此dp[i][j] = max(dp[i-1][j],dp[i][j-1])
遍历顺序：从左往右，正常顺序
确认边界：整个数组都是0, 1-based indexing防止-1的时候越界
答案：dp[m][n]. m和n是数组A和B的长度t
```

Python题解：

```python
# 拆分后赋值给a,b
a,b = input().split()
# 判断长度
m,n = len(a),len(b)
# dp数组的定义是dp[i][j]代表数组A的前i个字符和数组B的前j个字符的最长公共子序列长度，因此，二维数组的
# 行数，也就是一共有多少个嵌套的列表，列数，就是每一个嵌套的列表的长度，也就是n
# 长度为m+1和n+1，因为要1-based indexing，可以防止判断-1的时候越界
dp = [[0]*(n+1) for _ in range(m+1)]
# 从1开始遍历，到m也就是数组末位的索引，防止越界
for i in range(1,m+1):
    for j in range(1,n+1):
        # 判断两个数组的上一项，是否相等，回忆一下dp数组的定义，如果相等，就说明又多了一个公共字串，因此长度+1 
        if a[i-1] == b[j-1]:
            dp[i][j] = dp[i-1][j-1]+1
        else:
            dp[i][j] = max(dp[i-1][j],dp[i][j-1])
print(dp[m][n])
```

